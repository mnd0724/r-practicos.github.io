
pacman::p_load(sjlabelled,
               dplyr, #Manipulacion de datos
               stargazer, #Tablas
               sjmisc, # Tablas
               summarytools, # Tablas
               kableExtra, #Tablas
               sjPlot, #Tablas y gráficos
               corrplot, # Correlaciones
               sessioninfo, # Información de la sesión de trabajo
               ggplot2,
               haven,
               GGally) # Para la mayoría de los gráficos
rm(list=ls())       # borrar todos los objetos en el espacio de trabajo
options(scipen=999) # valores sin notación científica#Cargar base de datos

data <- read_dta("input/ELSOC_W01_v4.01_Stata14.dta")
View(data)
dim(data) #2927 428
names(data)

proc_data <- data %>% select(t06_01,
                             t06_02,
                             t06_03,
                             t06_04,
                             t06_06,
                             t08,
                             t10,
                             t11_04,
                             m29,
                             comuna,
                             region)
view(proc_data)
sjmisc::descr(proc_data)
proc_data <- proc_data %>% rename("sats_seguridad" =t06_01,
                                  "sats_conectividad"=t06_02, # Satisfacción conectividad
                                  "sats_averde"=t06_03, # Satisfacción área verde
                                  "sats_limpieza"=t06_04,# Satisfacción Limpieza
                                  "sats_colegios"=t06_06, #satisfacción cercanía a colegios de buena calidad 
                                  "percp_barrio"=t08,
                                  "percp_seguridad"=t10,
                                  "frq_vecinosbasura"=t11_04,
                                  "ingreso"=m29) # Ingresos total del hogar


#VER LOS NOMBRES DE LAS VARIABLES
names(proc_data)

#Filtrar por comunas de la región metropolitana
proc_data <- proc_data %>% dplyr::filter(region == "Metropolitana") # Filtrar por región (
proc_data <- filter(proc_data, comuna %in% c("Providencia",
                                             "Colina",
                                             "Maipu",
                                             "Las Condes",
                                             "Santiago",
                                             "Puente Alto",
                                             "La Florida",
                                             "San Bernardo"))

#La selección de estas comunas se hace respecto a la cantidad
#de personas encuestadas, y que sean lo más cercano posible en 
#en número de personas que participaron.

view(proc_data)

sjmisc::descr(proc_data,
              show = c("label","range", "mean", "sd", "NA.prc", "n"))%>%
  kable(.,"markdown")
summarytools::dfSummary(proc_data, plain.ascii = FALSE)
view(dfSummary(proc_data, headings=FALSE)) #Tabla como imagen
sum(is.na(proc_data))
proc_data <- proc_data %>%
  filter_all(all_vars(!is.na(.) & . != -999 & . != -888)) #Filtrar NA'S

summarytools::dfSummary(proc_data, plain.ascii = FALSE)
view(dfSummary(proc_data, headings=FALSE))  #SIN NA´S

#GRÁFICOS
proc_data %>% ggplot(aes(x = sats_seguridad)) + 
  geom_bar(fill = "coral")+
  labs(title = "Satisfacción Seguridad en el Barrio",
       x = "Satisfacción Seguridad",
       y = "Frecuencia")

proc_data %>% ggplot(aes(x = sats_conectividad)) + 
  geom_bar(fill = "coral")+
  labs(title = "Satisfacción Conectividad",
       x = "Satisfacción Conectividad",
       y = "Frecuencia")

proc_data %>% ggplot(aes(x = sats_averde)) + 
  geom_bar(fill = "coral")+
  labs(title = "Satisfacción área verde",
       x = "Satisfacción área verde",
       y = "Frecuencia")

proc_data %>% ggplot(aes(x = sats_limpieza)) + 
  geom_bar(fill = "coral")+
  labs(title = "Satisfacción Limpieza y Belleza en el Barrio",
       x = "Satisfacción Limpieza",
       y = "Frecuencia")

proc_data %>% ggplot(aes(x = sats_colegios)) + 
  geom_bar(fill = "coral")+
  labs(title = "Satisfacción cercanía a colegios de buena calidad",
       x = "Satisfacción cercanía a colegios de buena calidad",
       y = "Frecuencia")

proc_data %>% ggplot(aes(x = percp_barrio)) + 
  geom_bar(fill = "coral")+
  labs(title = "Percepción Evaluación del Barrio",
       x = "Percepción Evaluación del Barrio",
       y = "Frecuencia")

proc_data %>% ggplot(aes(x = frq_vecinosbasura)) + 
  geom_bar(fill = "coral")+
  labs(title = "Satisfacción Limpi",
       x = "Satisfacción Limpieza",
       y = "Frecuencia")


ggpairs(proc_data)

#2. ENTREGA 3 -----

view(dfSummary(proc_data, headings=FALSE, graph.col = FALSE))
cor(proc_data$sats_averde, proc_data$ingreso)
cor(proc_data$sats_conectividad, proc_data$ingreso)
cor(proc_data$sats_limpieza, proc_data$ingreso)
na.omit(proc_data)

#Sabemos que los valores de alfa van desde 0 y 1, cuando los valores
#son más cercanos a 1, existe una mayor confiabilidad 
#cuando el valor es mayor a 0.7 se considera como un valor aceptable
#Observamos que la variable

# Crear un vector con los nombres de las comunas
nombres_comunas <- c("Providencia", "Colina", "Las Condes", "Puente Alto", "La Florida", "Santiago", "Maipu", "San Bernardo")

# Ordenar alfabéticamente los nombres de las comunas
nombres_comunas <- sort(nombres_comunas)

# Crear un vector con los valores numéricos en orden alfabético
valores_numericos <- 1:length(nombres_comunas)

# Crear una nueva columna en el dataframe para asignar los valores numéricos
proc_data$comunas_numericas <- NA

# Asignar valores numéricos a las comunas
for (i in 1:length(nombres_comunas)) {
  proc_data$comunas_numericas[proc_data$comuna == nombres_comunas[i]] <- valores_numericos[i]
}

ggplot(proc_data, aes(x = comuna, y = sats_averde, fill = comuna)) +
  geom_bar(stat = "identity") +  # Utilizar stat = "identity" para usar los valores exactos de y
  labs(x = "Comuna", y = "Satisfacción con áreas verdes", title = "Satisfacción con áreas verdes por comuna") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotar las etiquetas del eje x para mejor legibilidad

#calcular el valor máximo en Ingreso
max_valor <- max(proc_data$ingreso)
#Imprimir el valor máximo
print(max_valor)

# Calcular el valor mínimo en la variable
min_valor <- min(proc_data$ingreso)
# Imprimir el valor mínimo
print(min_valor)

ggplot(proc_data, aes(x = comuna, y = ingreso)) +
  geom_point() +  # Agregar puntos al gráfico
  labs(x = "Comuna", y = "Ingresos", title = "Gráfico de Dispersión de Ingresos por Comuna") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotar las etiquetas del eje x para mejor legibilidad
  ylim(0, 8000000)

# Crear el gráfico de barras con escala logarítmica en el eje y y etiquetas personalizadas
ggplot(proc_data, aes(x = comuna, y = ingreso, fill = comuna)) +
  geom_bar(stat = "identity") +  # Utilizar stat = "identity" para usar los valores exactos de y
  labs(x = "Comuna", y = "Ingresos", title = "Ingresos por Comuna") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotar las etiquetas del eje x para mejor legibilidad
  scale_y_continuous(labels = scales::comma)  # Etiquetas personalizadas para los valores reales en el eje y

             